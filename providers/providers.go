package providers

import (
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Provider represenst a connection with a provider, each provider should have different
// connection to re-used the tcp connection to avoid create more than once.
type Provider struct {
	// ID represents the country-iso
	ID     string
	URL    *url.URL
	Client *http.Client
}

// Providers is useful to get an specific provider giving a key => country-iso.
// example: m["us"], or m["ru"]
// Each provider has its URL, and client connection.
type Providers map[string]Provider

// IsURL validates that the current string contains the schema, host, and port.
func IsURL(str string) (*url.URL, bool) {
	u, err := url.Parse(str)

	return u, (err == nil && u.Scheme != "" && u.Host != "" && u.Port() != "")
}

// New validates and generates a map with the providers given by the user.
// NOTE: if at least one arg is correct it's going to generate that provider.
func New(args []string) Providers {
	var (
		providers = make(map[string]Provider)
		errStr    = "args must be passed by the following format: ru=http://localhost:9001 us=http://localhost:9002"
	)

	// if the string is empty, then panic
	if len(args) == 0 {
		panic(errStr)
	}

	// validate each arg
	for i := range args {
		p := strings.Split(args[i], "=")

		if len(p) == 2 {
			if u, ok := IsURL(p[1]); ok {
				providers[p[0]] = Provider{
					ID:  p[0],
					URL: u,
					Client: &http.Client{
						// As request can't take more than 1 second we reduce it
						// in order to have time to get data from the cache.
						Timeout: 500 * time.Millisecond,
					},
				}
			}
		}
	}

	// if the providers was not generated by the before iteration then panic.
	if len(providers) == 0 {
		panic(errStr)
	}

	return providers
}
